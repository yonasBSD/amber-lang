// We cannot import `bash_version` from `env.ab` because it imports `text.ab` making a circular dependency.
// This is a workaround to avoid that issue and the import system should be improved in the future.
#[allow_absurd_cast]
fun bash_version(): [Int] {
    let major = 0
    let minor = 0
    let patch = 0
    trust $
        {nameof major}=\$\{BASH_VERSINFO[0]}
        {nameof minor}=\$\{BASH_VERSINFO[1]}
        {nameof patch}=\$\{BASH_VERSINFO[2]}
    $
    return [major, minor, patch]
}

/// Replaces all occurrences of a pattern in the content with the provided replace text.
///
/// ### Usage
/// ```ab
/// const result = replace("Hello world", "world", "universe")
/// echo(result) // "Hello universe"
/// ```
pub fun replace(source, search, replace) {
    // Here we use a command to avoid #646
    let result = ""
    if bash_version() >= [4, 3] {
        trust $ {nameof result}="\$\{{nameof source}//"\$\{{nameof search}}"/"\$\{{nameof replace}}"}" $
    } else {
        trust $ {nameof result}="\$\{{nameof source}//"\$\{{nameof search}}"/\$\{{nameof replace}}}" $
    }
    return result
}

/// Replaces the first occurrence of a pattern in the content with the provided replace text.
///
/// ### Usage
/// ```ab
/// const result = replace_one("foo foo foo", "foo", "bar")
/// echo(result) // "bar foo foo"
/// ```
pub fun replace_one(source, search, replace) {
    // Here we use a command to avoid #646
    let result = ""
    if bash_version() >= [4, 3] {
        trust $ {nameof result}="\$\{{nameof source}/"\$\{{nameof search}}"/"\$\{{nameof replace}}"}" $
    } else {
        trust $ {nameof result}="\$\{{nameof source}/"\$\{{nameof search}}"/\$\{{nameof replace}}}" $
    }
    return result
}

const SED_VERSION_UNKNOWN = 0
const SED_VERSION_GNU = 1
const SED_VERSION_BUSYBOX = 2

fun sed_version(): Int {
    // We can't match against a word "GNU" because
    // alpine's busybox sed returns "This is not GNU sed version"
    trust $ re='\bCopyright\b.+\bFree Software Foundation\b'; [[ \$(sed --version 2>/dev/null) =~ \$re ]] $
    if status == 0 {
        return SED_VERSION_GNU
    }
    // On BSD single `sed` waits for stdin. We must use `sed --help` to avoid this.
    trust $ re='\bBusyBox\b'; [[ \$(sed --help 2>&1) =~ \$re ]] $
    if status == 0 {
        return SED_VERSION_BUSYBOX
    }
    return SED_VERSION_UNKNOWN
}

/// Replaces all occurrences of a regex pattern in the content with the provided replace text.
/// Function uses `sed` and supports capture groups syntax in extended mode.
///
/// ### Usage
/// ```ab
/// const result = replace_regex("test123", "[0-9]+", "456", true)
/// echo(result) // "test456"
/// // Also supports replace regex
/// echo(replace_regex("Put number 255 in brackets", "([0-9]+)", "(\1)", true)); // Put number (255) in brackets
/// ```
pub fun replace_regex(source: Text, search: Text, replace_text: Text, extended: Bool = false): Text {
    trust {
        const sed_version = sed_version()
        search = replace(search, "/", "\\/")
        replace_text = replace(replace_text, "/", "\\/")
        if sed_version == SED_VERSION_GNU or sed_version == SED_VERSION_BUSYBOX {
            // '\b' is supported but not in POSIX standards. Disable it
            search = replace(search, "\\b", "\\\b")
        }
        if extended {
            // GNU sed versions 4.0 through 4.2 support extended regex syntax,
            // but only via the "-r" option
            if sed_version == SED_VERSION_GNU {
                return $ sed -r -e "s/{search}/{replace_text}/g" <<<"{source}" $
            } else {
                return $ sed -E -e "s/{search}/{replace_text}/g" <<<"{source}" $
            }
        } else {
            if sed_version == SED_VERSION_GNU or sed_version == SED_VERSION_BUSYBOX {
                // GNU Sed BRE handle \| as a metacharacter, but it is not POSIX standands. Disable it
                search = replace(search, "\|", "|")
            }
            return $ sed -e "s/{search}/{replace_text}/g" <<<"{source}" $
        }
    }
}

/// Splits the input `text` into an array of substrings using the specified `delimiter`.
///
/// ### Usage
/// ```ab
/// const parts = split("a,b,c", ",")
/// echo(parts[0]) // "a"
/// ```
pub fun split(text: Text, delimiter: Text): [Text] {
    let result = [Text]
    trust $ IFS="{delimiter}" read -rd '' -a {nameof result} < <(printf %s "\${nameof text}") $
    return result
}

/// Splits a `text` into an array of substrings based on newline characters.
///
/// ### Usage
/// ```ab
/// const lines = split_lines("line1\nline2\nline3")
/// echo(lines[0]) // "line1"
/// ```
pub fun split_lines(text: Text): [Text] {
    return split(text, "\n")
}

/// Splits a `text` into an array of substrings based on space character.
///
/// ### Usage
/// ```ab
/// const words = split_words("hello world example")
/// echo(words[1]) // "world"
/// ```
pub fun split_words(text: Text): [Text] {
    return split(text, " ")
}

/// Merges text using the delimiter specified.
///
/// ### Usage
/// ```ab
/// const joined = join(["a", "b", "c"], ",")
/// echo(joined) // "a,b,c"
/// ```
pub fun join(list: [Text], delimiter: Text): Text {
    return trust $ IFS="{delimiter}" ; printf "%s\n" "\$\{{nameof list}[*]}" $
}

/// Trims the spaces at top of the text using `sed`.
///
/// ### Usage
/// ```ab
/// const trimmed = trim_left("   hello")
/// echo(trimmed) // "hello"
/// ```
pub fun trim_left(text: Text): Text {
    let result = ""
    trust $ {nameof result}="\$\{{nameof text}#\$\{{nameof text}%%[![:space:]]*}}" $
    return result
}

/// Trims the spaces at end of the text using `sed`.
///
/// ### Usage
/// ```ab
/// const trimmed = trim_right("hello   ")
/// echo(trimmed) // "hello"
/// ```
pub fun trim_right(text: Text): Text {
    let result = ""
    trust $ {nameof result}="\$\{{nameof text}%\$\{{nameof text}##*[![:space:]]}}" $
    return result
}

/// Trims the spaces from the text input.
///
/// ### Usage
/// ```ab
/// const trimmed = trim("   hello   ")
/// echo(trimmed) // "hello"
/// ```
pub fun trim(text: Text): Text {
    let result = ""
    trust $ {nameof result}="\$\{{nameof text}#\$\{{nameof text}%%[![:space:]]*}}" $
    trust $ {nameof result}="\$\{{nameof result}%\$\{{nameof result}##*[![:space:]]}}" $
    return result
}

/// Makes the text input lowercase using `tr`.
///
/// ### Usage
/// ```ab
/// const lower = lowercase("HELLO")
/// echo(lower) // "hello"
/// ```
pub fun lowercase(text: Text): Text {
    return trust $ tr '[:upper:]' '[:lower:]' <<< "{text}" $
}

/// Makes the text input uppercase using `tr`.
///
/// ### Usage
/// ```ab
/// const upper = uppercase("hello")
/// echo(upper) // "HELLO"
/// ```
pub fun uppercase(text: Text): Text {
    return trust $ tr '[:lower:]' '[:upper:]' <<< "{text}" $
}

/// Attempts to parse a given text into an `Int` number.
///
/// ### Usage
/// ```ab
/// const num = parse_int("42")?
/// echo(num) // 42
/// ```
#[allow_absurd_cast]
pub fun parse_int(text: Text): Int? {
    $ [ -n "{text}" ] && [ "{text}" -eq "{text}" ] 2>/dev/null $?
    return text as Int
}

/// Attempts to parse a given text into a `Num` number.
///
/// ### Usage
/// ```ab
/// const num = parse_num("3.14")?
/// echo(num) // 3.14
/// ```
#[allow_absurd_cast]
pub fun parse_num(text: Text): Num? {
    const re_int="^-?[0-9]+$"
    const re_float="^-?[0-9]*\.[0-9]+$"

    $ [[ {text} =~ {re_int} ]] || [[ {text} =~ {re_float} ]] $?
    return text as Num
}

/// Splits a text into an array of individual characters.
///
/// ### Usage
/// ```ab
/// const chars = split_chars("hello")
/// echo(chars[0]) // "h"
/// ```
pub fun split_chars(text: Text): [Text] {
    let chars = [Text]
    trust $ for ((i=0; i<\$\{#{nameof text}}; i++)); do
        {nameof chars}+=( "\$\{{nameof text}:\$i:1}" );
    done $
    return chars
}

/// Checks if some text contains a value.
///
/// ### Usage
/// ```ab
/// if text_contains("hello world", "world") {
///     echo("Found!")
/// }
/// ```
pub fun text_contains(source: Text, search: Text): Bool {
    trust $ [[ "{source}" == *"{search}"* ]] $
    return status == 0
}

/// Checks if an array value is in the text.
///
/// ### Usage
/// ```ab
/// if text_contains_any("hello world", ["foo", "world", "bar"]) {
///     echo("Found at least one!")
/// }
/// ```
pub fun text_contains_any(source: Text, searches: [Text]): Bool {
    for search in searches {
        if text_contains(source, search) {
            return true
        }
    }

    return false
}

/// Checks if all the arrays values are in the string
///
/// ### Usage
/// ```ab
/// if text_contains_all("hello world", ["hello", "world"]) {
///     echo("All found!")
/// }
/// ```
pub fun text_contains_all(source: Text, searches: [Text]): Bool {
    for search in searches {
        if not text_contains(source, search) {
            return false
        }
    }
    return true
}

/// Match all occurrences of a regex pattern.
///
/// Function uses `sed`
///
/// ### Usage
/// ```ab
/// if match_regex("test123", "[0-9]+", true) {
///     echo("Contains numbers!")
/// }
/// ```
pub fun match_regex(source: Text, search: Text, extended: Bool = false): Bool {
    trust {
        const sed_version = sed_version()
        search = replace(search, "/", "\/")
        let output = ""
        if sed_version == SED_VERSION_GNU or sed_version == SED_VERSION_BUSYBOX {
            // '\b' is supported but not in POSIX standards. Disable it
            search = replace(search, "\\b", "\\\b")
        }
        if extended {
            // GNU sed versions 4.0 through 4.2 support extended regex syntax,
            // but only via the "-r" option
            if sed_version == SED_VERSION_GNU {
                // '\b' is not in POSIX standards. Disable it
                search = replace(search, "\b", "\\b")
                output = $ sed -r -ne "/{search}/p" <<<"{source}" $
            } else {
                output = $ sed -E -ne "/{search}/p" <<<"{source}" $
            }
        } else {
            if sed_version == SED_VERSION_GNU or sed_version == SED_VERSION_BUSYBOX {
                // GNU Sed BRE handle \| as a metacharacter, but it is not POSIX standands. Disable it
                search = replace(search, "\|", "|")
            }
            output = $ sed -ne "/{search}/p" <<<"{source}" $
        }
        if output != "" {
            return true
        }
    }
    return false
}

/// Checks if an array value (with regular expression) is in the text.
///
/// ### Usage
/// ```ab
/// if match_regex_any("test123", ["[a-z]+", "[0-9]+"]) {
///     echo("Matches at least one pattern!")
/// }
/// ```
pub fun match_regex_any(text: Text, terms: [Text]): Bool {
    for term in terms {
        if match_regex(text, term, false) {
            return true
        }
    }

    return false
}

/// Reverses text using `rev`.
///
/// ### Usage
/// ```ab
/// const reversed_text = reversed("hello")
/// echo(reversed_text) // "olleh"
/// ```
pub fun reversed(text: Text): Text {
    return trust $ rev <<< "{text}" $
}

/// Checks if text starts with a value.
///
/// ### Usage
/// ```ab
/// if starts_with("hello world", "hello") {
///     echo("Starts with hello!")
/// }
/// ```
pub fun starts_with(text: Text, prefix: Text): Bool {
    trust $ [[ "{text}" == "{prefix}"* ]] $
    return status == 0
}

/// Checks if text ends with a value.
///
/// ### Usage
/// ```ab
/// if ends_with("hello world", "world") {
///     echo("Ends with world!")
/// }
/// ```
pub fun ends_with(text: Text, suffix: Text): Bool {
    trust $ [[ "{text}" == *"{suffix}" ]] $
    return status == 0
}

/// Returns a substring from `text` starting at the given `index` (0-based).
///
/// If `index` is negative, the substring starts from the end of `text` based on the absolute value of `index`.
/// If `length` is provided, the substring will include `length` characters; otherwise, it slices to the end of `text`.
/// If `length` is negative, an empty string is returned.
///
/// ### Usage
/// ```ab
/// const sub = slice("hello world", 6, 5)
/// echo(sub) // "world"
/// ```
pub fun slice(text: Text, index: Int, length: Int = 0): Text {
    let result = ""
    if length == 0: length = len(text) - index
    if length <= 0: return result
    trust $ {nameof result}="\$\{{nameof text}: {index}: {length}}" $
    return result
}

/// Returns the character from `text` at the specified `index` (0-based).
///
/// If `index` is negative, the substring starts from the end of `text` based on the absolute value of `index`.
///
/// ### Usage
/// ```ab
/// const ch = char_at("hello", 1)
/// echo(ch) // "e"
/// ```
pub fun char_at(text: Text, index: Int): Text {
    let result = ""
    trust $ {nameof result}="\$\{{nameof text}:{index}:1}" $
    return result
}

/// Capitalize the first letter of the given `text`.
///
/// ### Usage
/// ```ab
/// const cap = capitalized("hello")
/// echo(cap) // "Hello"
/// ```
#[allow_absurd_cast]
pub fun capitalized(text: Text): Text {
    trust {
        if len(text) == 0 {
            return text
        }
        if bash_version() >= [4] {
            return $ printf '%s\n' "\$\{{nameof text}^}" $
        }
        if sed_version() == SED_VERSION_GNU {
            // GNU sed supports \U
            return $ printf '%s\n' "{text}" | sed "s/^\(.\)/\U\1/" $
        }
        const first_letter = uppercase(char_at(text, 0))
        return first_letter + slice(text, 1)
    }
}

/// Pads `text` with the specified `pad` character on left until it reaches the desired `length`.
///
/// ### Usage
/// ```ab
/// const padded = lpad("42", "0", 5)
/// echo(padded) // "00042"
/// ```
pub fun lpad(text: Text, pad: Text, length: Int): Text {
    if length <= len(text): return text
    const pad_len = length - len(text)
    let padding = ""
    trust $ printf -v {nameof padding} "%{pad_len}s" "" $
    trust $ {nameof padding}="\$\{{nameof padding}// /{pad}}" $
    return padding + text
}

/// Pads `text` with the specified `pad` character on the right until it reaches the desired `length`.
///
/// ### Usage
/// ```ab
/// const padded = rpad("42", "0", 5)
/// echo(padded) // "42000"
/// ```
pub fun rpad(text: Text, pad: Text, length: Int): Text {
    if length <= len(text): return text
    const pad_len = length - len(text)
    let padding = ""
    trust $ printf -v {nameof padding} "%{pad_len}s" "" $
    trust $ {nameof padding}="\$\{{nameof padding}// /{pad}}" $
    return text + padding
}

/// Pads `text` with zeros on the left until it reaches the desired `length`.
///
/// ### Usage
/// ```ab
/// const padded = zfill("42", 5)
/// echo(padded) // "00042"
/// ```
pub fun zfill(text: Text, length: Int): Text {
    return lpad(text, "0", length)
}

/// Counts the number of lines in the given text.
///
/// ### Usage
/// ```ab
/// const count = count_lines("one\ntwo\nthree")
/// echo(count) // 3
/// ```
#[allow_absurd_cast]
pub fun count_lines(text: Text): Int {
    if text == "": return 0
    return trust $ wc -l <<< "{text}" | tr -d ' ' $ as Int
}

/// Counts the number of words in the given text.
///
/// ### Usage
/// ```ab
/// const count = count_words("hello world foo")
/// echo(count) // 3
/// ```
#[allow_absurd_cast]
pub fun count_words(text: Text): Int {
    return trust $ wc -w <<< "{text}" | tr -d ' ' $ as Int
}

/// Counts the number of characters in the given text.
///
/// ### Usage
/// ```ab
/// const count = count_chars("hello")
/// echo(count) // 5
/// ```
#[allow_absurd_cast]
pub fun count_chars(text: Text): Int {
    return trust $ printf "%s" "{text}" | wc -m | tr -d ' ' $ as Int
}

/// Sorts lines of text in ascending, descending or numerial order.
///
/// ### Usage
/// ```ab
/// let sorted = sort_lines("banana\napple\ncherry")
/// echo(sorted) // "apple\nbanana\ncherry"
/// 
/// sorted = sort_lines("banana\napple\ncherry", true) // Sorts lines of text in descending order
/// echo(sorted) // "cherry\nbanana\napple"
/// 
/// sorted = sort_lines("10\n2\n1", false, true) // Sorts lines of text numerically
/// echo(sorted) // "1\n2\n10"
/// ```
pub fun sort_lines(text: Text, desc: Bool = false, numeric: Bool = false): Text {
    let args = ""
    if desc: args += "r"
    if numeric: args += "n"
    return trust $ sort -{args} <<< "{text}" $
}

/// Removes duplicate lines from text.
///
/// ### Usage
/// ```ab
/// let result = uniq_lines("foo\nfoo\nbar\nbar\nbaz")
/// echo(result) // "foo\nbar\nbaz"
///
/// let result = uniq_lines("foo\nbar\nfoo\nbaz\nbar", true) /// Removes all duplicate lines from text (not just consecutive)
/// echo(result) // "foo\nbar\nbaz"
/// ```
pub fun uniq_lines(text: Text, remove_all: Bool = false): Text {
    if not remove_all:
        return trust $ uniq <<< "{text}" $
    else: 
        return trust $ awk '!seen[\$0]++' <<< "{text}" $
}
