import * from "std/fs"
import { array_find } from "std/array"
import * from "std/text"

/// Retrieves the value of an environment variable, optionally sourcing it from a file if not already set.
///
/// ### Usage
/// ```ab
/// let value = env_var_load("MY_VAR", ".env.local")
/// ```
pub fun env_var_load(var: Text, file: Text = ".env"): Text {
    const _var = trust $ printf "%s\n" "\$\{!{nameof var}}" $
    if _var != "" {
        return _var
    }

    if file_exists(file) {
        trust $ source "{file}" $
        return trust $ printf "%s\n" "\$\{!{nameof var}}" $
    }

    return ""
}

/// Loads the env file in the environment, using `xargs`.
///
/// ### Usage
/// ```ab
/// env_file_load(".env")
/// ```
pub fun env_file_load(file: Text = ".env"): Null {
    trust $ export "\$(xargs < {file})" > /dev/null $
}

/// Checks if a variable inside the shell session exists.
///
/// ### Usage
/// ```ab
/// if env_var_test("PATH") {
///     echo "PATH exists"
/// }
/// ```
pub fun env_var_test(name: Text): Bool {
    $ [[ ! -z \$\{!{nameof name}+z} ]] $ failed {
        return false
    }
    return true
}

/// Sets a constant inside the shell session. Note that `true` is saved as int (`1`).
///
/// ### Usage
/// ```ab
/// env_const_set("API_KEY", "secret123")
/// ```
pub fun env_const_set(name: Text, val: Text | Int | Bool): Null? {
    $ readonly \${nameof name}="\${nameof val}" 2> /dev/null $?
}

/// Sets a variable inside the shell session. Note that `true` is saved as int (`1`).
///
/// ### Usage
/// ```ab
/// env_var_set("STATUS","succeeded")
/// env_var_set("COUNT", 100)
/// env_var_set("DEBUG", true) // saved as int (`1`)
/// ```
pub fun env_var_set(name: Text, val: Text | Int | Bool): Null? {
    $ export \${nameof name}="\${nameof val}" 2> /dev/null $?
}

/// Gets a variable or constant inside the shell session.
///
/// ### Usage
/// ```ab
/// let debug = env_var_get("DEBUG")
/// ```
pub fun env_var_get(name: Text): Text? {
    return $ printf "%s\n" "\$\{!{nameof name}}" $?
}

/// Removes a variable inside the shell session.
///
/// ### Usage
/// ```ab
/// env_var_unset("TEMP_VAR")
/// ```
pub fun env_var_unset(name: Text): Null? {
    $ unset {name} $?
}

/// Checks if a command exists.
///
/// ### Usage
/// ```ab
/// if is_command("git") {
///     echo "Git is installed"
/// }
/// ```
pub fun is_command(command: Text): Bool {
    $ [ -x "\$(command -v "{command}")" ] $ failed {
        return false
    }
    return true
}

/// Creates a prompt and returns the value.
///
/// ### Usage
/// ```ab
/// let name = input_prompt("Enter your name: ")
/// ```
pub fun input_prompt(prompt: Text): Text {
    trust $ read -p "\${nameof prompt}" || read -p "\${nameof prompt}" < /dev/tty $
    return trust $ printf '%s\n' \$REPLY $
}

/// Creates a prompt, hides any user input and returns the value.
///
/// ### Usage
/// ```ab
/// let password = input_hidden("Enter password: ")
/// ```
pub fun input_hidden(prompt: Text): Text {
    trust {
        $ read -s -p "\${nameof prompt}" || read -s -p "\${nameof prompt}" < /dev/tty $
        $ echo "" >&2 $
        return $ printf '%s\n' \$REPLY $
    }
}

/// Creates a confirm prompt (Yes/No), and returns true if the choice is Yes.
///
/// "No" is the default choice, set default_yes to true for "Yes" as default choice.
///
/// ### Usage
/// ```ab
/// if input_confirm("Continue?", false) {
///     echo "Continuing..."
/// }
/// ```
pub fun input_confirm(prompt: Text, default_yes: Bool = false): Bool {
    const choice_default = default_yes then " [\x1b[1mY/\x1b[0mn]" else " [y/\x1b[1mN\x1b[0m]"
    trust {
        $ printf "\x1b[1m{prompt}\x1b[0m{choice_default}" $
        $ read -s -n 1 || read -s -n 1 < /dev/tty $
        $ printf "\n" $
    }
    const result = lowercase(trust $ printf '%s\n' \$REPLY $)
    return result == "y" or (result == "" and default_yes)
}

/// Checks if the command has failed.
///
/// ### Usage
/// ```ab
/// if has_failed("test -f config.txt") {
///     echo "File doesn't exist"
/// }
/// ```
pub fun has_failed(command: Text): Bool {
    trust silent $ eval {command} $
    return status != 0
}

/// Checks if the script is running with a user with root permission.
///
/// ### Usage
/// ```ab
/// if is_root() {
///     echo "Running as root"
/// }
/// ```
pub fun is_root(): Bool {
    if trust $ id -u $ == "0" {
        return true
    }

    return false
}

/// `printf` the text following the arguments.
///
/// ### Usage
/// ```ab
/// printf("Hello %s!", ["World"])
/// ```
pub fun printf(format: Text, args: [Text] = []): Null {
    trust $ {nameof args}=("{format}" "\$\{{nameof args}[@]}") $
    trust $ printf "\$\{{nameof args}[@]}" $
}

/// Escapes the text to be used with `printf`.
///
/// ### Usage
/// ```ab
/// printf("%s\n", [escaped("100% done\\n")])
/// ```
pub fun escaped(text: Text): Text {
    return trust $ printf "%s\n" "\${nameof text}" | sed -e 's/\\\\/\\\\\\\\/g' -e "s/%/%%/g" $
}

/// Prepares a text with formatting options for `printf`.
///
/// ### Usage
/// ```ab
/// printf("%s\n", [styled("Error!", 1, 31, 40)])
/// printf("%s\n", [styled("Warning!", 1, "white", "yellow")])
/// ```
///
/// ### Supported color names
/// | Color name | Foreground code | Background code |
/// | - | - |
/// | black | 30 | 40 |
/// | red | 31 | 41 |
/// | green | 32 | 42 |
/// | yellow | 33 | 43 |
/// | orange | 93 | 103 |
/// | blue | 34 | 44 |
/// | purple | 35 | 45 |
/// | cyan | 36 | 46 |
/// | gray | 37 | 47 | 
/// | white | 97 | 107 |
///
/// For all supported color codes, please visit https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit
pub fun styled(message: Text, style: Int, fg: Int | Text, bg: Int | Text): Text {
    // https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit
    const colors_name = ["black", "red", "green", "yellow", "orange", "blue", "purple", "cyan", "gray", "white"]
    let fg_code = 0
    let bg_code = 0
    if bg is Text {
        const colors_code = [40, 41, 42, 103, 43, 44, 45, 46, 47, 97]
        const color_index = array_find(colors_name, bg)
        if color_index == -1: echo_error("Invalid background color name provided", 1)
        bg_code = colors_code[color_index]
    } else { 
        bg_code = bg
    }

    if fg is Text {
        const colors_code = [30, 31, 32, 93, 33, 34, 35, 36, 37]
        const color_index = array_find(colors_name, fg)
        if color_index == -1: echo_error("Invalid foreground color name provided", 1)
        fg_code = colors_code[color_index]
    } else {
        fg_code = fg
    }
    return "\x1b[{style};{fg_code};{bg_code}m{escaped(message)}\x1b[0m"
}

/// Returns a text as bold.
///
/// ### Usage
/// ```ab
/// printf("%s\n", [bold("Important message")])
/// ```
pub fun bold(message: Text): Text {
    return "\x1b[1m{escaped(message)}\x1b[0m"
}

/// Returns a text as italic.
///
/// ### Usage
/// ```ab
/// printf("%s\n", [italic("Emphasized text")])
/// ```
pub fun italic(message: Text): Text {
    return "\x1b[3m{escaped(message)}\x1b[0m"
}

/// Returns a text as underlined.
///
/// ### Usage
/// ```ab
/// printf("%s\n", [underlined("Underlined text")])
/// ```
pub fun underlined(message: Text): Text {
    return "\x1b[4m{escaped(message)}\x1b[0m"
}

/// Prints a text with a specified color.
///
/// ### Usage
/// ```ab
/// echo_colored("Red text", "red")
/// echo_colored("Blue text", 34)
/// ```
/// 
/// ### Supported color names
/// | Color name | Code |
/// | - | - |
/// | black | 30 |
/// | red | 31 |
/// | green | 32 |
/// | yellow | 93 |
/// | orange | 33 |
/// | blue | 34 |
/// | purple | 35 |
/// | cyan | 36 |
/// | gray | 37 |
/// | white | 97 |
///
/// For all supported color codes, please visit https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit
pub fun echo_colored(message: Text, color: Text | Int): Null {
    let color_code = 0
    if color is Text {
        // https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit
        const colors_name = ["black", "red", "green", "yellow", "orange", "blue", "purple", "cyan", "gray", "white"]
        const colors_code = [30, 31, 32, 93, 33, 34, 35, 36, 37, 97]
        const color_index = array_find(colors_name, color)
        if color_index == -1: echo_error("Invalid color name provided", 1)
        color_code = colors_code[color_index]
    } else {
       color_code = color
    }
    printf("\x1b[{color_code}m%s\x1b[0m\n", [message])
}

/// Prints a text as a info message.
///
/// ### Usage
/// ```ab
/// echo_info("Information message")
/// ```
pub fun echo_info(message: Text): Null {
    printf("\x1b[1;3;97;44m%s\x1b[0m\n", [message])
}

/// Prints a text as a success message.
///
/// ### Usage
/// ```ab
/// echo_success("Operation completed successfully")
/// ```
pub fun echo_success(message: Text): Null {
    printf("\x1b[1;3;97;42m%s\x1b[0m\n", [message])
}

/// Prints a text as a warning message.
///
/// ### Usage
/// ```ab
/// echo_warning("Warning: Disk space low")
/// ```
pub fun echo_warning(message: Text): Null {
    printf("\x1b[1;3;97;43m%s\x1b[0m\n", [message])
}

/// Prints a text as a error and exits if the status code is greater than 0.
///
/// ### Usage
/// ```ab
/// echo_error("Fatal error occurred", 1)
/// ```
pub fun echo_error(message: Text, exit_code: Int = 1): Null {
    printf("\x1b[1;3;97;41m%s\x1b[0m\n", [message])
    if exit_code > 0 : exit(exit_code)
}

/// Returns current bash version with major, minor and patch components.
///
/// ### Usage
/// ```ab
/// let version = bash_version()
/// echo "Bash {version[0]}.{version[1]}.{version[2]}"
/// ```
#[allow_absurd_cast]
pub fun bash_version(): [Int] {
    const major = trust $ printf "%s\n" "\$\{BASH_VERSINFO[0]}" $ as Int
    const minor = trust $ printf "%s\n" "\$\{BASH_VERSINFO[1]}" $ as Int
    const patch = trust $ printf "%s\n" "\$\{BASH_VERSINFO[2]}" $ as Int
    return [major, minor, patch]
}
